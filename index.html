<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>飄動幽靈（反向拖曳 + 基礎飄移）</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #panorama{position:fixed;inset:0}

  /* 幽靈放前景，用 CSS 變數控制位移（中心為 0,0） */
  #ghost{
    position:fixed; left:50%; top:50%;
    transform: translate(calc(-50% + var(--gx, 0px)), calc(-50% + var(--gy, 0px)));
    width:clamp(250px, 30vmin, 600px);
    pointer-events:none; user-select:none; -webkit-user-drag:none;
    opacity:.9; z-index:30;
    filter: drop-shadow(0 10px 22px rgba(0,0,0,.55));
    will-change: transform;
  }

  /* 手持手機固定在中下，高度 70% 螢幕 */
  .holding-phone{
    position:fixed; left:50%; bottom:0; transform:translateX(-50%);
    height:70vh; width:auto; pointer-events:none; z-index:25;
    filter: drop-shadow(0 8px 18px rgba(0,0,0,.4));
  }

  /* UI */
  .intro{
    position:fixed; inset:0; display:grid; place-items:center; z-index:100;
    background:rgba(0,0,0,.6);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",sans-serif;
  }
  .intro-card{
    background:rgba(15,23,42,.9); color:#e2e8f0; border:1px solid rgba(255,255,255,.15);
    border-radius:16px; max-width:min(720px,92vw); padding:20px; box-shadow:0 8px 30px rgba(0,0,0,.5);
  }
  .intro-card h2{margin:0 0 .7rem; font-size:1.15rem; line-height:1.4}
  .intro-card p{margin:.2rem 0 1rem; opacity:.9}
  .btn{
    display:inline-block; padding:.85rem 1.2rem; border:0; border-radius:12px;
    background:#22c55e; color:#0b1220; font-weight:700; cursor:pointer;
  }

  .end-wrap{
    position:fixed; inset:0; display:none; place-items:center; z-index:110;
    background:rgba(0,0,0,.45);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",sans-serif;
  }
  .end-btn{
    padding:1rem 1.3rem; border:0; border-radius:12px; background:#38bdf8; color:#0b1220; font-weight:800; cursor:pointer;
    box-shadow:0 10px 28px rgba(0,0,0,.45); text-decoration:none;
  }
</style>
</head>
<body>

<div id="panorama"></div>

<!-- 開場指示 -->
<div class="intro" id="intro">
  <div class="intro-card">
    <h2>拖曳螢幕，將手機對著女人，聽完對話。<br>Drag the screen, aim the phone at the woman, and listen to the conversation.</h2>
    <p>按下按鈕後開始偵測與播放。/ Start detection and audio after you press the button.</p>
    <button class="btn" id="startBtn" type="button">知道了！ / Got it!</button>
  </div>
</div>

<!-- 播畢跳轉 -->
<div class="end-wrap" id="endWrap">
  <a id="fallbackLink" class="end-btn" href="https://ths.li/nNKw9mg" target="_top" rel="noopener">
    去榕樹洞 / Go to the banyan tree hollow
  </a>
</div>

<!-- 前景素材 -->
<img src="ghost.png" id="ghost" alt="">
<img src="holdingphone.png" class="holding-phone" id="holdingPhone" alt="">

<script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>
<script>
/* ========= 1) Panorama ========= */
const viewer = pannellum.viewer('panorama', {
  type:'equirectangular',
  panorama:'panorama.jpg',
  autoLoad:true,
  showControls:true,
  hfov:100,
  backgroundColor:[0,0,0]
});

/* ========= 2) DOM refs ========= */
const intro = document.getElementById('intro');
const startBtn = document.getElementById('startBtn');
const ghost = document.getElementById('ghost');
const phone = document.getElementById('holdingPhone');
const endWrap = document.getElementById('endWrap');
const fallbackLink = document.getElementById('fallbackLink');

/* ========= 3) Audio ========= */
const audio = new Audio('ghostaudio.mp3');
audio.preload = 'auto';
audio.loop = false;

/* ========= 4) 幽靈物理（螢幕座標） =========
   ghost 的位置以 px 為單位，相對於畫面中心（0,0）
   gx, gy: 目前位移；vb: 基礎飄移速度；拖曳時會把反向拖曳速度疊加上去
*/
let gx = 0, gy = 0;
let vb = { x: 20, y: 10 };           // 基礎飄移速度（px/s），可自行調整大小與方向
let vbTarget = { x: 20, y: 10 };     // 每隔幾秒讓基礎速度慢慢變化
let dragActive = false;
let lastPointer = { x: 0, y: 0 };
let monitoring = false;
let lastT = 0;

// 安全邊界，避免飄出畫面
const marginVW = 8, marginVH = 8;

/* 隨機更換基礎飄移方向（更自然） */
setInterval(()=>{
  const speed = 20 + Math.random()*25; // 20~45 px/s
  const ang = Math.random()*Math.PI*2;
  vbTarget.x = Math.cos(ang)*speed;
  vbTarget.y = Math.sin(ang)*speed;
}, 6000);

/* ========= 5) 反向拖曳：把指標位移量的「負號」加到幽靈 ========= */
function onPointerDown(e){
  dragActive = true;
  lastPointer.x = e.clientX;
  lastPointer.y = e.clientY;
}
function onPointerMove(e){
  if(!dragActive) return;
  const dx = e.clientX - lastPointer.x;
  const dy = e.clientY - lastPointer.y;
  // 反向，同速
  gx -= dx;
  gy -= dy;
  lastPointer.x = e.clientX;
  lastPointer.y = e.clientY;
}
function onPointerUp(){ dragActive = false; }

/* 同時支援滑鼠與觸控（Pointer Events） */
['pointerdown','pointermove','pointerup','pointercancel','pointerleave'].forEach(type=>{
  // 綁在 viewer 容器即可；Pannellum 仍會照常接收拖曳
  document.getElementById('panorama').addEventListener(type, (e)=>{
    if(type==='pointerdown') onPointerDown(e);
    else if(type==='pointermove') onPointerMove(e);
    else onPointerUp();
  }, {passive:true});
});

/* ========= 6) 主迴圈：基礎飄移 + 反向拖曳後的位置，並做邊界限制 ========= */
function clampToViewport(){
  const vw = window.innerWidth, vh = window.innerHeight;
  const maxX = vw*(0.5 - marginVW/100);
  const minX = -maxX;
  const maxY = vh*(0.5 - marginVH/100);
  const minY = -maxY;
  if (gx >  maxX) gx =  maxX;
  if (gx <  minX) gx =  minX;
  if (gy >  maxY) gy =  maxY;
  if (gy <  minY) gy =  minY;
}

function raf(t){
  if(!monitoring){ requestAnimationFrame(raf); return; }
  const dt = (t - (lastT||t))/1000; lastT = t;

  // 慢慢把基礎速度逼近目標，製造微妙飄移變化
  vb.x += (vbTarget.x - vb.x) * Math.min(1, dt*0.6);
  vb.y += (vbTarget.y - vb.y) * Math.min(1, dt*0.6);

  // 套用基礎飄移
  gx += vb.x * dt;
  gy += vb.y * dt;

  clampToViewport();

  // 透過 CSS 變數更新幽靈位置
  ghost.style.setProperty('--gx', gx + 'px');
  ghost.style.setProperty('--gy', gy + 'px');

  // 碰撞偵測（手機上緣掃到幽靈）
  const gRect = ghost.getBoundingClientRect();
  const pRect = phone.getBoundingClientRect();
  const phoneTop = pRect.top;
  const overlapX = !(pRect.right < gRect.left || pRect.left > gRect.right);
  const hit = overlapX && phoneTop <= gRect.bottom && phoneTop >= gRect.top;

  if (hit) {
    if (audio.paused && !audio.ended) audio.play().catch(()=>{});
  } else {
    if (!audio.paused && !audio.ended) audio.pause();
  }

  requestAnimationFrame(raf);
}

/* ========= 7) 啟動 / 結束 ========= */
startBtn.addEventListener('click', ()=>{
  intro.style.display = 'none';
  monitoring = true;
  lastT = performance.now();
});

audio.addEventListener('ended', ()=>{
  endWrap.style.display = 'grid';
});

/* 指定整頁跳轉（含 sandbox fallback） */
(function(){
  const targetURL = "https://ths.li/nNKw9mg";
  function replaceTop(url){
    try { window.top.location.replace(url); }
    catch(err){
      console.warn("Top navigation blocked:", err);
      document.getElementById('fallbackLink').click();
    }
  }
  fallbackLink.addEventListener('click', function(e){
    e.preventDefault(); replaceTop(targetURL);
  });
})();

/* 啟動 RAF（直到按下「知道了」才開始進入計算分支） */
requestAnimationFrame(raf);
</script>

<noscript>需要啟用 JavaScript 才能檢視 360° 全景。</noscript>
</body>
</html>
